from datetime import datetime, timedelta
from flask import current_app
from app.models import QuizAttempt, User
from app import db
import hashlib
import secrets
import json


class AccessCodeService:

    @staticmethod
    def generate_access_code(attempt_id: str, teacher_id: str) -> str:
        """Generate a fresh access code for a quiz attempt"""
        try:
            attempt = QuizAttempt.query.filter_by(id=attempt_id).first()
            if not attempt:
                raise ValueError("Attempt not found")

            # Verify teacher owns the quiz
            if attempt.quiz.created_by != teacher_id:
                raise ValueError("Unauthorized: You don't own this quiz")

            # Generate unique code based on attempt ID and current timestamp
            timestamp = datetime.utcnow().isoformat()
            code_data = f"{attempt_id}_{timestamp}_{secrets.token_hex(4)}"
            access_code = hashlib.sha256(
                code_data.encode()).hexdigest()[:8].upper()

            # Store the code with expiration (5 minutes)
            code_record = {
                'attempt_id': attempt_id,
                'access_code': access_code,
                'generated_by': teacher_id,
                'generated_at': timestamp,
                'expires_at': (datetime.utcnow() + timedelta(minutes=5)).isoformat(),
                'used': False
            }

            # Store in attempt metadata (in a real implementation, this would be a separate table)
            if not attempt.reset_reason:
                attempt.reset_reason = json.dumps({})

            reasons = json.loads(attempt.reset_reason)
            reasons['access_code'] = code_record
            attempt.reset_reason = json.dumps(reasons)

            db.session.commit()

            return access_code

        except Exception as e:
            current_app.logger.error(f"Error generating access code: {str(e)}")
            raise

    @staticmethod
    def verify_access_code(attempt_id: str, access_code: str, device_info: dict = None) -> bool:
        """Verify an access code for a quiz attempt"""
        try:
            attempt = QuizAttempt.query.filter_by(id=attempt_id).first()
            if not attempt:
                return False

            # Get stored code record
            reasons = json.loads(attempt.reset_reason or '{}')
            code_record = reasons.get('access_code')

            if not code_record:
                return False

            # Check if code matches
            if code_record['access_code'] != access_code.upper():
                return False

            # Check if code is expired
            expires_at = datetime.fromisoformat(code_record['expires_at'])
            if datetime.utcnow() > expires_at:
                return False

            # Check if already used
            if code_record.get('used', False):
                return False

            # Mark code as used
            code_record['used'] = True
            code_record['used_at'] = datetime.utcnow().isoformat()
            if device_info:
                code_record['device_info'] = device_info

            reasons['access_code'] = code_record
            attempt.reset_reason = json.dumps(reasons)

            # Reset escape attempts
            # In a real implementation, this would be stored in the attempt
            db.session.commit()

            return True

        except Exception as e:
            current_app.logger.error(f"Error verifying access code: {str(e)}")
            return False

    @staticmethod
    def get_active_access_codes(teacher_id: str) -> list:
        """Get all active access codes generated by a teacher"""
        try:
            # This is a simplified implementation
            # In a real app, this would query a dedicated access_codes table
            attempts = QuizAttempt.query.join(QuizAttempt.quiz).filter(
                Quiz.created_by == teacher_id,
                QuizAttempt.status == 'IN_PROGRESS',
                QuizAttempt.reset_reason.isnot(None)
            ).all()

            active_codes = []
            for attempt in attempts:
                try:
                    reasons = json.loads(attempt.reset_reason or '{}')
                    code_record = reasons.get('access_code')

                    if code_record and not code_record.get('used', False):
                        expires_at = datetime.fromisoformat(
                            code_record['expires_at'])
                        if datetime.utcnow() < expires_at:
                            active_codes.append({
                                'attempt_id': attempt.id,
                                'student_name': attempt.student.name,
                                'quiz_title': attempt.quiz.title,
                                'access_code': code_record['access_code'],
                                'generated_at': code_record['generated_at'],
                                'expires_at': code_record['expires_at'],
                                'student_id': attempt.student_id
                            })
                except:
                    continue

            return active_codes

        except Exception as e:
            current_app.logger.error(
                f"Error getting active access codes: {str(e)}")
            return []

    @staticmethod
    def revoke_access_code(attempt_id: str, teacher_id: str) -> bool:
        """Revoke an active access code"""
        try:
            attempt = QuizAttempt.query.filter_by(id=attempt_id).first()
            if not attempt or attempt.quiz.created_by != teacher_id:
                return False

            reasons = json.loads(attempt.reset_reason or '{}')
            if 'access_code' in reasons:
                del reasons['access_code']
                attempt.reset_reason = json.dumps(reasons)
                db.session.commit()
                return True

            return False

        except Exception as e:
            current_app.logger.error(f"Error revoking access code: {str(e)}")
            return False
